第一课

数据类型：

整型：INT(4Bytes) SMALLINT(2Bytes) MEDIUMINT(3Bytes) BIGINT(8Bytes)  占用空间越大，存储的数值就越大。

int(11)VS int(21),这两者存储空间有区别还是存储范围有区别？答案是本质上没有区别。
eg:
create table t (a int(11) zerofill , b int(21) zerofill);
insert into t values (1,1);
select * from t;

drop table t;
create table t (a int(11) , b int(21));
insert into t values (1,1);
select * from t;


浮点型： FLOAT(M,D)     DOUBLE(M,D)

属性       存储空间          精度                    精确性
float      四字节            单精度                  非精确
double     八字节            双精度                  比float精度高

精度丢失：
eg:
CREATE TABLE 't' (
'a' int(11) DEFAULT NULL,
'b' float(7,4) DEFAULT NULL
) ENGINE-InnoDB DEFAULT CHARSET=uft8
;

insert into t values (2,123.12345);
select * from t;


定点数-更精确的数字类型：

DECIMAL：
高精度的数据类型，常用来存储交易相关的数据。
DECIMAL(M,N) M代表总精度，N代表小数点右侧的位数（标度）。
1<M<254,0<N<60
存储空间变长（存储空间会变动）

如何存储性别信息和省份信息：  enum(枚举类型)
属性       数据类型            数据格式                                  存储空间
tinyint    number              1:woman 2:man                             1字节
char(1)    string              M/W                                       1字节
enum       string              enum('woman','man')                       1字节/2字节

经验之谈：
存储性别，省份，类型等分类信息时选择TINYINT或者ENUM
BIGINT存储空间更大，INT和BIGINT之间通常选择BIGINT
交易等高精度数据时选择使用DECIMAL
     


第二课

存储用户名的属性：

char:

varchar:
text:

char与varchar存储的单位都是字符

字符与字节的区别：
编码\输入字符串                   网易                        netease
GBK（双字节）                     varchar(2)/4字节            varchar(7)
UTF8(三字节)                      varchar(2)/6字节            varchar(7)
UTF8MB4(四字节)                   varchar(2)/？               varchar(7)

emoji表情
JAVA程序支持emoji表情
MYSQL版本>5.5.3
JDBC驱动版本>5.1.13
库和表的字符集设为utf8mb4

如果选择uft8和utf8mb4，那么优选utf8mb4

char和varchar的区别：
char存储字长，容易造成空间的浪费
varchar存储变长，节省存储空间

text与char和varchar的区别：
char和varchar存储单位为字符。
text存储单位为字节，总大小为65535字节，约为64KB
char数据类型最大为255字符
varchar数据类型为变长存储，可以存储超过255个字符
text在数据库内部大多存储格式为溢出页，效率不如char


存储头像：
BLOB:
BINARY:
这两个虽然都可以用来存储头像，但是非常不推荐。
那用什么存？


经验之谈：
char和varchar定义的长度是字符长度不是字节长度
存储字符串推荐选择使用varchar(n),n尽量小。
虽然数据库可以存储二进制数据，但是性能低下，不要使用数据库存储文件音频等二进制数据。


存储生日信息：
DATE:
TIME:
DATETIME:
TIMESTAMP:
BIGINT:


时间类型的区别在哪里：
存储空间上的区别：
DATE三字节，如：2015-05-01
TIME三字节，如：11:12:00
TIMESTAMP四字节，如：2015-05-01 11:12:00
DATETIME八字节，如：2015-05-01 11:12:00

存储精度的区别：
DATE精确到年月日
TIME精确到小时分钟和秒
TIMESTAMP、DATETIME都包含上述两者


TIMESTAMP VS DATETIME
存储范围的区别：
TIMESTAMP存储范围：1970-01-01 00:00:00 to 2038-01-19 03:14:07
DATETIME的存储范围：1000-01-01 00:00:00 to 9999-12-31 23:59:59
在MYSQL5.6版本以后这两个都可以支持到微秒。

字段类型与时区的关联关系：
TIMESTAMP会根据系统时区进行转换，DATETIME则不会。
所以，如果设计国际化的系统，则推荐TIMESTAMP。

eg:
create table test (a datetime, b timestamp);
show create table test/G
select now();
insert into test values(now(),now());
select * from test;
set time_zone = '+00:00';
select * from test;
set time_zone = '+08:00';
select * from test;


BIGINT如何存储时间类型：
应用程序将时间转为数字类型

BIGINT需要把时间转化为UNIXTIME(MySQL的UNIX_TIMESTAMP()),反向则可以使用(MySQL的from_unixtime(),shell的date -d @XXXX)

自找的参考资料：http://blog.csdn.net/lxpbs8851/article/details/8604747
如果看不懂就百度关键词：UNIX_TIMESTAMP()



第三课



数据类型与数据对象的区别：
行为：
基本类型只是一个值，没有任何行为
对象类型有自己的行为
内存分配：
基本类型在栈内分配
对象在堆内分配
对象引用保存在栈内
引用与值：
基本类型是值类型，仅表示一个值，保存在栈内
引用类型分两部分，对象引用保存在栈内，对象保存在堆内，
访问变量，是使用的引用找对象



数据对象：
DataBase/Schema:
Tabel:
Index(索引):
View(视图)/Trigger(触发器)/Function(函数)/Procedure(存储过程):

库、表、行层级关系：
一个DataBase对应一个Schema
一个Schema包含一个或多个表
一个表里面包含一个或者多个字段
一个表里包含一条或多条记录
一个表包含一个或多个索引

多Database用途:
业务的隔离：比如服务器性能强大，跑一个表浪费，那就建多个database。
资源的隔离：比如一个database里资源过多，搜索过慢，那就建多个database分离一下资源。

表上有哪些常用的数据对象：
索引：
约束：
视图、触发器、函数、存储过程：

什么是数据库索引：
读书的时候如何快速的定位某一个章节：
查找书籍目录。
在自己喜欢的章节夹书签，但是书签太多的话，不容易维护。
索引就相当于查找书籍目录。

索引就是数据库中数据的目录：
索引和数据是两个对象。
索引主要是用来提高数据库的查询效率。
数据库中数据变更同样需要同步索引数据的变更。(这里在设计数据库的时候要注意，否则变更一条数据就要变更很多的索引，那就麻烦了。)

如何创建索引（一）：
help create index:


CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name
    [USING index_type]
    ON tbl_name (index_col_name,...)
 
index_col_name:
    col_name [(length)] [ASC | DESC]


如果只是key的话，就是普通索引。（表级创建）
如create table t(id int, key keyid (id));


如何创建索引（二）：
help alter table:



使用alter的方法创建索引
alter table table_name add index index_name (column_list) ;
alter table table_name add unique (column_list) ;
alter table table_name add primary key (column_list) ;
查询索引
SHOW INDEX FROM table_name;
删除索引
drop index index_name on table_name ;
alter table table_name drop index index_name ;
alter table table_name drop primary key ;




约束：
生活中的约束有哪些：
每个人的指纹信息必须唯一
每个人的身份证要求唯一
网上购物需要先登录才能下订单

唯一约束：
对一张表的某个字段或者某几个字段设置唯一键约束，保证在这个表里对应的数据必须唯一，如：用户ID、手机号、身份证号等。

创建唯一约束：
唯一约束是一种特殊的索引
唯一约束可以是一个或者多个字段
唯一约束可以在建表的时候建好，也可以后面再补上
主键也是一种唯一约束

索引有哪些：
主键索引：ID
单键索引：orderid
单键索引：bookid
组合索引：(userid+orderid)

唯一约束有哪些：
主键约束：id
单键唯一索引：orderid
组合唯一索引：(userid+orderid)

添加唯一约束：
添加主键：
mysql>alter talbe 'order' add primary key (id);
添加唯一索引：
mysql>alter table 'order' add unique key idx_uk_orderid (orderid);

外键约束：
外键指两张表的数据通过某种条件关联起来。

如果没有外键约束：
可以用应用程序来保证外键约束。用应用程序来作判断。

创建外键约束：
将用户表和订单表通过外键关联起来：
mysql>alter table 'order' add CONSTRAINT constarint_uid FOREIGN KEY(userid) REFERENCES user(userid);
如果创建成功的话，可以在show create table 'order'\G来查看，下面会显示如下内容：
KEY 'constarint_uid' ('userid'),
CONSTRAINT 'constarint_uid' FOREIGN KEY ('userid') REFERENCES 'user' ('userid')

使用外键约束的注意事项：
必须是INNODB表，Myisam和其它引擎不支持外键。
相互约束的字段类型必须要一样。
主表的约束字段要求有索引。
约束名称必须要唯一，即便不在一张表上。

eg:
create table 'order' (
'id' int(11) NOT NULL AUTO_INCREMENT,
'bookid' int(10) NOT NULL DEFAULT '0',
'userid' int(10) NOT NULL DEFAULT '0',
'number' tinyint(3) NOT NULL DEFAULT '0',
'address' varchar(128) NOT NULL DEFAULT '',
'postcode' varchar(6) NOT NULL DEFAULT '',
'orderdate' datetime NOT NULL DEFAULT '000-00-00 00:00:00',
'status' tinyint(3) unsigned zerofill DEFAULT '000',
PRIMARY KEY ('id'),
KEY 'bookid'('bookid'),
KEY 'idx_uid'('userid'),
CONSTRAINT 'constarint_uid' FOREIGN KEY ('userid') REFERENCES 'user' ('userid')
)ENGINE-InnoDB DEFAULT CHARSET=latin1

alter table 'order' modify userid int(10) unsigned NOT NULL DEFAULT '0';

show create table 'order'\G;
会显示'userid' int(10) unsigned NOT NULL DEFAULT '0',

alter table 'order' add CONSTRAINT constarint_uid FOREIGN KEY (userid) REFERENCES user(userid);
会报错，后面会有errno:150  查这个编号就查出来错误在哪。百度查。

下面再把他改回去：
alter table 'order' modify userid int(10) NOT NULL DEFAULT '0';
alter talbe 'order' add CONSTRAINT constarint_uid FOREIGN KEY (userid) REFERENCES user(userid);

约束名必须是唯一的，现在这个添加了一个constarint_uid ,如果再给其它的表添加这个。就会报错。
alter table 'order_1' add CONSTRAINT constarint_uid FOREIGN KEY (userid) REFERENCES user_1(userid);
会报错。

alter table 'order_1' add CONSTRAINT constarint_uid_new FOREIGN KEY (userid) REFERENCES user_1(userid);
会成功。

show create table 'order_1'\G;
会显示成功添加。

View:
产品需求：
假如有其它部门的同事想查询我们数据库里的数据，但是我们并不想暴露表的结构，并且只提供给他们部分数据。
怎么办？
两种方法：
第一种，开发一个接口，通过接口返回需要的数据。
第二种，就是通过视图。

View的作用：
视图将一组查询语句构成的结果集，是一种虚拟结构，并不是实际数据。
视图能简化数据库的访问，能够将多个查询语句结构化为一个虚拟结构。
视图可以隐藏数据库后端表结构，提高数据库的安全性。
视图也是一种权限管理，只对用户提供部分数据。

创建View:
创建已完成订单的视图：
create view order_view as select * from 'order' where status=1;

Trigger:
产品需求：
随着用户个人等级的提升，系统需要自动更新用户的积分，其中一共有两张表，分别为：用户信息表和积分表。

两种方法：
第一种，通过应用程序来实现。
第二种，通过Trigger来实现。

数据库实现：
Trigger:
Trigger俗称触发器，指可以在数据写入表A之前或者之后可以做一些其它动作。
使用Trigger在每次更新用户表的时候触发更新积分表。

除此之外还有哪些：
Function:MYSQL提供了很多很多函数，基本可以满足应用。如果不满足，就需要自定义一部分函数。
Procedure（存储过程）:存储的一部分指令集。通过传入参数，返回想要得到的结果。




以下是imooc.com关于约束的讲解：

第2-12课:

主键：
每张数据表只能存在一个主键
主键保证记录的唯一性
主键自动为NOT NULL
AUTO_INCREMENT必须和主键一起使用，但是主键不必与AUTO_INCREMENT一起使用。

eg:
create table tb3(
id smallint unsigned auto_increment promary key,
username varchar(30) not null,
);

show columns from tb3;

insert tb3 (username) values ('tom');
insert tb3 (username) values ('rose');
insert tb3 (username) values ('dimitar');

select * from tb3;


eg2:
create table tb4 (
id smallint unsigned primary key,
username varchar(20) not null
);

show columns from tb4;

insert tb4 values(4,'tom');
insert tb4 values(22,'john');

insert tb4 values (22,'rose');




第2-13课

unique key:
唯一约束：
唯一约束可以保证记录的唯一性
唯一约束的字段可以为空值（NULL）(虽然可以为空值，但是空值只能有一个。)
每张数据表可以存在多个唯一约束

创建一个即有主键，也有唯一约束的例子：
eg:
create table tb5 (
id smallint unsigned auto_increment primary key,
username varchar(20) not null unique key,
age tinyint unsigned);

show columns from tb5;

insert into tb5 (username,age) values('tom',22);
insert into tb5 (username,age) values('tom',22);----会报错。因为唯一约束。

在忘记写的时候如何添加唯一约束：
alter table tb5 add unique key (username);





第2-14课

default:
默认约束：
当插入记录时，如果没有明确为字段赋值，则自动赋予默认值。

eg:
create table tb6(
id smallint unsigned auto_increment primary key,
username varchar(20) not null unique key,
sex enum('1','2','3') default '3'
);

show columns from tb6;

insert into tb6 (username) values('tom');





第3-2课

foreign key:
外键约束：
作用：
保持数据一致性，完整性
实现一对一或一对多关系。

外键约束的要求：
1、父表和子表必须使用相同的存储引擎，而且禁止使用临时表。
2、数据表的存储引擎只能为InnoDB。
3、外键列和参照列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同，而字符的长度则可以不同。
4、外键列和参照列必须创建索引。如果外键列不存在索引的话，MYSQSL将自动创建索引。参照列如果不提前创建，则不会，但是注意，如果加过主键的话，会自动创建索引。

如果默认创建的表不是InnoDB怎么办？可以修改MYSQL配置文件my.ini内部的default-storage-engine=INNODB

eg:
create table provinces(
id smallint unsigned promary key auto_increment,
pname varchar(20) not null
);

show create table provinces;

create table users(
id smallint unsigned primary key auto_increment,
username varchar(10) not null,
pid bigint,
foreign key (pid) references provinces(id)
);
---报错，因为pid的数据类型和父表的数据类型不同。
另外，符号不同的话，也会报错。

create table users(
id smallint unsigned primary key auto_increment,
username varchar(10) not null,
pid smallint unsigned,
foreign key (pid) references provinces(id)
);

show indexes from provinces\G;

show indexes from users\G;

show create table users;---这样也可以查看是否有索引，带key的字段，就是带了索引。




第3-3课

外键约束的参照操作：

1、cascade:父表删除或更新时，自动删除或更新子表中匹配的行。
2、set null:从父表删除或更新行，会设置子表中的外键列为NULL。如果使用该选项，必须保证子表列没有指定not null.
3、restrict:拒绝对父表的删除或更新操作。 
4、no action:标准SQL的关键字，在MYSQL中与restrict相同。

eg:
参照列不变，还是上面那个。
下面创建带有外键列的表：
create table users1(
id smallint unsigned primary key auto_increment,
username varchar(10) not null,
pid smallint unsigned,
foreign key (pid) references provinces (id) on delete cascade
);


show create table users1;

分别在两张表中插入记录：（必须先在父表中插入，才能再在子表中插入）

insert into provinces (pname) values('a'); 
insert into provinces (pname) values('b');
insert into provinces (pname) values('c');

select * from provinces;

insert into users1 (username,pid) values('tom',3);
insert into users1 (username,pid) values('john',7);----报错，在父表中不存在这个ID
insert into users1 (username,pid) values('john',1);
insert into users1 (username,pid) values('rose',3);

select * from users1;

delete from provinces where id=3;

select * from provinces;

select * from users1;

因为引擎的关系，所以很少使用物理的外键约束，多使用逻辑的外键约束。




第3-5课

修改数据表---添加单列：
语法：alter table tbl_name add column col_name column_definition [ first | after col_name ]
eg:alter table users1 add column age tinyint unsigned not null default '10';
alter table users1 add column password varchar(32) unsigned not null after username;
alter table users1 add column truename varchar(20) not null first;

添加多列：
语法：alter table tbl_name add[column] (col_name column_definition,...)
添加多列不能指定添加的位置，只能添加在最后，而且列要用括号括起来，并且中间要用逗号隔开。

删除列：
alter table tbl_name drop [column] col_name;
eg:alter table users1 drop column truename;

删除多列：
eg:alter table users1 drop password,drop age;
alter table users1 drop pid,add aa varchar(10) unsigned not null default '20';


第3-6课

添加主键约束：
alter table tbl_name add [constraint [symbol]] primary key [index_type] (index_col_name,...)

eg:
create table users2(
username varchar(10) not null,
pid smallint unsigned
);

show create table users2;

alter table users2 add column id smallint unsigned ;

show columns from users2;

alter table users2 add constraint PK_users2_id primary key (id);

show columns from users2;


添加唯一约束：
alter table tbl_name add [constraint [symbol]] unique [index|key] [index_name] [index_type] (index_col_name,...)

eg:
alter table users2 add unique (username);

show create table users2;


添加外键约束：

alter table tbl_name add [constraint [symbol]] foreign key [index_name] (index_col_name,...) references_definition

eg:
alter table users2 add forergn key (pid) references provinces(id);

show create table users2;


添加、删除默认约束：
alter table tbl_name alter [column] col_name {set default literal| drop default}

eg:
alter table users2 add age tinyint unsigned not null;

show columns from users2;

alter table users2 alter age set default 15;

show columns from users2;

alter table users2 alter age drop default;



删除约束：

删除主键约束：
alter table tab_name drop primary key 

eg:
alter table users2 drop primary key;

show columns from users2;

删除唯一约束：

alter table tbl_name drop {index|key} index_name

eg:
show indexes from users2\G;

alter table users2 drop index username;

show columns from users2;

show indexes from users2\G;

删除外键约束：
alter table tbl_name drop foreign key fk_symbol   
首先要查看到外键的名称，然后删除外键，删除完外键以后，还有个索引，再删除索引，就完成了。

eg:
show create table users2;

alter table users2 drop foreign key users2_ibfk_1;

show create table users2;

alter table users2 drop index pid;

show create table users2;



第3-8课

修改列定义：可以用modify修改列的类型，位置等，但是如果从大类型修改到小类型，容易造成数据的丢失。
            修改列名字用change

alter table tbl_name modify [column] col_name column_definition [first|after col_name]

eg:
alter table users2 modify column id samllint unsigned not null first;

show columns from users2;

修改列名称：change即可以修改列名称，也可以修改列属性。
alter table tbl_name change [column] old_col_name new _col_name column_definition [first|after col_name]
eg:
alter table users2 change pid pi_d smallint unsigned not null;


修改数据表名：
方法1：
alter table tbl_name rename[to|as] new_tbl_name

方法2：
rename table tbl_name to new_tbl_name [,tbl_name2 to new_tbl_name2]...


方法1eg:
alter table users2 rename users3;

show tables;

方法2eg:
rename table users3 to users2;

show tables;

注意：尽量少使用列的更名和表的更名，其它地方引用的话，会出错。

小结：修改定义用modify ，修改列名用change，修改表名用rename;




第4-2课

记录的增删改查：
插入：
insert [into] tbl_name [(col_name)] {values|value} ({expr|default},...),(...),...
eg:
create table users(
id samllint unsigned primary key auto_increment,
username varchar(20) not null,
password varchar(32) not null,
age tinyint unsigned not null, default 10,
sex boolean
);

insert users values(null,'tom','123',25,1);

select * from users;

如果想为自动编号的记录赋值，可以赋值为null或者default

insert users values(null,'john','456',25,1);

insert users values(default,'tom','123',25,1);

当列的值和赋值的值不匹配，则会返回错误。

值可以以表达式来表示：(数学表达式、字符表达式、函数)
insert users values(null,'rose',3*7-5,1);

如果某个列的值存在默认值， 并且想将默认值赋值给这个记录的话，可以填写default
eg:
insert users values(null,'tom','123',default,1);

select * from users;

可以一次性的写入多条记录。两个值之间用逗号分隔。

insert users values(null,'tom',md5('123'),default,0),(null,'dilit',md5('456'),default,1);



第4-2课 ***********************

插入记录insert set:
insert [into] tbl_name set col_name={expr|default},...
说明：与第一种方式的区别在于，此方法可以使用子查询（subquery）
eg:
insert users set username='ben',password='456';

select * from users;


插入记录select:
insert[into] tbl_name [(col_name,...)] select ...
说明：此方法可以将查询结果插入到指定的数据表。


第4-3课

更新记录（单表更新）
单表更新记录update:
update [low_priority] [ignore] table_reference set col_name1={expr1|default} [,col_name2={expr2|default}]...[where where_condition]

eg:
update users set age=age+5;

select * from users;

update users set age=age-id,sex=0;

select * from users;

update users set age=age+10 where id % 2 = 0;

select * from users;


第4-4课

删除记录（单表删除）：
delete from tbl_name [where where_condition]

eg:
delete from users where id=6;

select * from users;

insert users values(null,'111','222',33,null);

select * from users;



第4-5课

查询表达式解析：

select select_expr [,select_expr...][

from table_references
[where where_condition]
[group by {col_name | position} [asc|desc],...]
[having where_condition]
[order by {col_name | expr | position} [asc | desc],...]
[limit {[offset,] row_count | row_count offset offset}]
]

eg:
select version();
select now();


查询表达式：
每一个表达式表示想要的一列，必须有至少一个。
多个列之间以英文逗号分隔。
星号(*)表示所有列。tbl_name.*可以表示命名表的所有列。
查询表达式可以使用[AS]alias_name为其赋予别名。
别名可用于group by ,order by 或having子句。

查询具体某一列或某些列：
select id,username from users;

在多表连接的情况下查询某一列或某些列的方法：
select users.id,users.username from users;

查询表达式可以使用[AS]alias_name为要查询字段的结果集赋予别名。
select id as userid,username as uname from users;



第4-7课

where语句进行条件查询：
条件表达式：
对记录进行过滤，如果没有指定where子句，则显示所有记录。
在where表达式中，可以使用MYSQL支持的函数或运算符。



第4-8课

group by 语句对查询结果分组：
[group by {col_name | position} [asc | desc],...]

eg:
select * from users;

select sex from users group by sex;

select sex from users group by 1;
1指的是这个select语句中第一个出现的字段。在这里1就是sex，因为sex出现在了这个查询语句所查询的字段的第一位(其实也没有其它的位了)。



第4-9课

having语句设置分组条件：
[having where_condition]

eg:
select sex from users group by 1 having age >35;---报错，因为字段不符。
select sex,age from users group by 1 having age>35;

select sex from users group by 1 having count(id) >=2;---可以接受函数。



第4-10课

order by 语句对查询结果排序：
[order by {col_name | expr | position} [asc | desc],...]

eg:
select * from users;

select * from users order by id desc;

select * from users order by age;

select * from users order by age,id desc;



第4-11课

limit语句限制查询数量：
限制查询结果返回的数量：
[limit {[offset,] row_count | row_count offset offset}]

eg:
select * from users;

从第一条开始返回，返回两条记录：
select * from users limit 2;

从第3条开始返回，返回两条记录：(注意：结果集是从0开始记数的)
select * from users limit 2,2;



限制返回记录的时候，限制的是查询好的结果集，并不是原表数据。
select * from users order by id desc;

select * from users order by id desc limit 2,2;




返回前面学习的内容，插入记录：
insert [into] tbl_name set col_name={expr | default},...
说明：与第一种方式的区别在于，此方法可以使用子查询（subquery）
insert[into] tbl_name [(col_name,...)] select ...
将获取到的内容插入到指定的数据表中。
可以将查找的结果存储到指定的数据表:

insert new_tbl_name(new_columns) select old_columns from old_tbl_name;

eg:
create table test (
id tinyint unsigned primary key auto_increment,
username varchar(20)
);

select * from test;

insert test select username from users where age>=30;

insert test(username) select username from users where age>=30;

select * from test;





























  



























































