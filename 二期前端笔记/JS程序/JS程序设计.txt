1、JS介绍

2、JS调试

调试面板的右上角会显示有多少个错误，然后在console面板中会显示错误内容，并在后面跟上错误的文件及行数。

检查错误：根据写代码的思路，一步一步的检查看错误在哪里。

可以用alert(xx);来检测某个变量是值。但是这个需要点击，比较麻烦。所以可以使用console.log(xx);

如果变量比较多，就需要用到JS的调试器：
chrome:Sources窗口
左侧是文件窗口，中间是调试的文件窗口，文件窗口左侧可以设置断点。
右侧有4个按钮，第一个是继续执行按钮，第二个是单步执行按钮 ，第三个是进入函数按钮，第四个是退出函数按钮。
右侧中间是调试的信息。如果想查看特殊的变量，可以在Watch Expressions中添加变量。
Call Stack是堆栈。
Sources面板中也可以直接打开Console面板。

操作：
打开Sources面板后，在左侧找到相应的需要调试文件，如果文件较多，可以用ctrl+o来查找，输入文件名即可。
如果要调试某个函数，在找到函数后，在函数内第一行设置一个断点（点击行号即可）。
如果函数较多，可以ctrl+shift+o来进行查找。
设置断点以后，在函数中进行操作，函数就会停到断点的那一行。然后就可以用右侧按钮进行调试。
点击单步执行，就会从上一个语句跳到下一个语句。
在Scope中的Local中可以看到局部变量，在Global中可以看到全局变量。
可以在Watch中添加想要查看的变量。直接输入变量名即可。
可以按ESC按键调出Console面板。
想看哪个变量的值，就在Console面板中直接输入变量名即可。
在某一行有其它的函数，如果想查看该函数内容，点击进入函数按钮，即可进入查看。
的Call Stack中可以看到函数的堆栈（被哪个函数调用方法）。
在堆栈中点击调用函数的方法，就可以回到该方法的作用域中。
如果想退出该函数，就可以点击退出函数按钮。
当调试完毕以后，就可以点击继续执行按钮让函数继续执行。
调试结束。

单步执行会执行当前行，然后跳到下一行等待。
继续执行会将当前文件执行一遍。如果中间有其它的断点，会停到下一个断点上。
+
Console面板不只是可以输入变量，还可以改变变量的值。
当运行到某个函数以后，前面有变量XX，那就可以通过 XX=10;来改变XX的值。

注：在调试代码的时候不能输入console.log  alert  等等。如果想输入这些，需要在真实代码里输入。


3、基本语法

同时声明多个变量:
eg:
var name='abc',
    age=18,
    sex='man';

关键字和保留字：
var case=1;  
上面的语句运行以后会提示：SyntaxError:missing variable name  (没有变量名)
这种的就是关键字或者保留字。

ReferenceError:Age is not defined  (Age没有定义)

4、基本类型

数字类型有两个特殊值：NaN和Infinity(无穷大，这个有正负值。)

null类型：表示一个空对象，对象不存在。
如果一个对象将来要表示是一个object对象，那在没有初始化之前，可以将他赋值为一个null。

undefined类型：
出现场景：已声明未赋值的对象    获取对象不存在的属性

类型识别方法：typeof
eg:
var num=1;
typeof num; //number

原始类型和引用类型的区别:
原始类型值是单独的，改变一个，另一个不改变。
引用类型值是指针形式的，改变一个，另一个也会改变。

 
5、运算符与表达式

++age 和age++：前加加会先加加，再走其它，后加加会先走语句中的其它部分，再加加。
eg:
var age=29;
var num=age++; //num=29
这里先走的赋值，然后才会加加。

空的数组转换成布尔值是true  eg:alert(![]);    //false

想取得某个类型的布尔值：可以用!!
eg:alert(!![]);   //true


逻辑操作符：
&&:如果逻辑与的第一个操作符是false，那么第二个操作是不会进行的。如果第一个操作符是true,就是返回第二个值。
eg:
var obj=""||num++;   //false  第二个加加是不会运行的。

||:如果逻辑或的第一个操作符是true,那么第二个操作是不会进行的。
eg:
var obj=1 || num++; //这里num++是不会进行的。

对象操作符：
delete:删除对象属性
eg: delete cat.name;  //可以删除一个对象的属性。

instanceof:判断某个变量是否是某个对象的实例
eg:
var cat={name:'kitty',age:2};
alert(cat instanceof Object);   //true

in:判断某个属性是否在对象中
eg:
var cat={name:'kitty',age:2};
alert('name' in cat); //true

操作符优先级：如果操作符优先级不确定的话，最保险的办法就是加括号。


6、语句

条件语句除了if  esle之外，还有一种是switch语句
switch(条件句){

case 值1: 语句
break;
case 值2: 语句
break;
default:语句

}


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>switch语句</title>
</head>
<body>
<script>
  var degree = 'B';
  switch(degree){
    case 'A':
      document.write('优秀');
      break;
    case 'B':
      document.write('良好');
      break;
    default:
      document.write('合格');
  }

</script>
</body>
</html>

循环语句：
循环中会用到两个关键字：break和continue
break:跳出循环
continue:跳过当次循环，进入下一次循环。


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>for语句</title>
</head>
<body>
<script>
  for(var i = 1; i <= 10; i++){
    document.write(i);
  }

  /*for(var i = 1;i <= 10;i++){
    if(i == 5){break;}
    document.write(i);
  }

  for(var i = 1;i <= 10;i++){
   if(i == 5){continue;}
   document.write(i);
  }*/


</script>

</body>
</html>

for-in循环：用来遍历对象中的属性名。(for(属性名 in 对象) {语句})

with语句：with(表达式){语句}
作用：将当前语句中的代码的作用域指向一个特殊的对象上，所以一般情况下表达式里面会是一个对象。


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>with语句</title>
</head>
<body>
<script>
  var kitty = {
    age:3,
    friend:{
      name:'snoopy',
      age:2
    }
  }

  with(kitty.friend){
    document.write(name + '\'s age is' + age);   //将name age的作用域指向了kitty.friend这个对象。
  }

</script>
</body>
</html>



异常捕获语句：
try{
语句
}catch(exception){
语句
}finally{
语句
}

try一个语句，如果出错，则exception里面会是错误，下面语句就是对这个错误执行的语句。
然后不论try语句是否出错，都会执行finally中的语句。


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>try catch语句</title>
</head>
<body>
<script>
  try{
    document.write(notDefined);
  }catch(error){
    console.log(error);
    alert(error);
  }finally{
    alert('finally');
  }
</script>
</body>
</html>


7、数值

绝对值：Math.abs(x)      abs:absolute

四舍五入：Math.round(x)  注：可以通过四舍五入将一个浮点型的数值转换成一个整型的数值。

向上取整：Math.ceil(x)   注：向上取整就是取大数。

向下取整：Math.floor(x)  注：向下取整就是取小数。

取最大值：Math.max([value1[,value2[,...]]])  注：取若干个数里的最大值。

取最小值：Math.min([value1[,value2[,...]]])  注：取若干个数里的最小值。

随机数：  Math.random()  注：这个随机数的范围是 0<=x<1


将字符串转换成整型数字：parseInt(string,radix)
接受两个参数，第一个参数是字符串，第二个参数是输出的进制。第二个参数通常不用。
将获取到的字符串转换成数字，并向下取整。
如果字符串内有非数字，则从非数字开始后面全部丢弃。如果第一个就是非数字，则输出NaN

将字符串转换成浮点型数字：parseFloat(string)
如果字符串内有非数字，则从非数字开始后面全部丢弃。如果第一个就是非数字，则输出NaN

将内容转换成数字：Number(value)
这个得到的结果是浮点型数字。
如果内容里面有非数字，则整个都输出为NaN
注：这里的Number的N要大写。
Number(12.4b5);  //NaN

保留X位小数点：num.toFixed(digits)
前面的num是需要操作的数字，后面的参数是要保留的小数点位数。
注：前面的数字需要用括号括起来，因为数字里面有小数点。
注2：输出的数字是字符串。
eg:(100.123).toFixed(2)       //100.12


8、字符串

字符串的长度：str.length;

字符串某个位置的字符：str.charAt(index)
eg:
if('-micr'.charAt(0)=='-'){
alert("首字符不能为'-'");
}

所查找的字符的所在位置（可以用来判断字符是否存在）：str.indexOf(searchValue[,formIndex])
接受两个参数，第一个参数是要查找的字符，第二个参数是查找的起始位置（很少用）。
注：该方法只匹配一次。
eg:
if('mi-cr'.indexOf('-')==-1){
alert("必须包含'-'");
}

返回满足参数条件的第一个字符的所在位置:str.search(regexp)
接受一个参数，参数可以是正则表达式。
if('micr'.search(/[0-9]/)!=-1){
alert("不能包含数字");

}

返回和条件参数所匹配的字符，查到的内容会形成数组返回:str.match(regexp)
接受一个参数，参数可以是正则表达式。
如果查找的内容不存在，就会返回null
'micr123'.match(/[0-9]/g)    //['1','2','3']

替换相关的字符：str.replace(regexp | substr,newSubstr | function)
接受两个参数，第一个参数可以是一个正则，也可以是将要替换的字符串。
第二个参数是要替换成的字符串，或者是函数（函数很少用）。
该函数并不会去改变原有的字符串，而是返回一个全新的字符串。需要将返回的字符串重新赋值到新的变量上，才能正常的使用。
eg:
'micr123'.replace('123','###');    //micr###

查找字符串内指定位置的字符：str.substring(indexA[,indexB])
查找到的内容包含indexA,但是不包含indexB
如果只传入一个参数，就是从该参数到末尾。
eg:
'micr123'.substring(2,5)   //'cr1'

查找字符串内指定位置的字符：str.slice(beginSlice[,endSlice])
和substring基本相似，不同的地方是这个函数的参数可以传入负值。
eg:
'micr123'.slice(1,-1);     //'icr12'

查找字符串内指定位置的字符：str.substr(start[,length])
这个函数和substring的区别在于，这个第二个参数是一个长度。
就是从开始位置，取多少长度的字符。
eg:
'micr123'.substr(2,2);    //'cr'

按照分隔符分隔字符串：str.split([separator][,limit])
接收两个参数，第一个参数是按照什么分隔符来分隔。第二个参数是提取多少个内容（不常用）
参数可以接收正则表达式。
eg:
'micr 123'.split(' ');    //['micr','123']

全部转换成小写：str.toLowerCase()

全部转换成大写：str.toUpperCase()

特殊的符号需要转义：\
比如双引号内的双引号，反斜线后的反斜线
\t   会是一个tab符号
\n   会是一个换行


根据字符找位置：str.indexOf()  str.search()

根据字符找字符：str.match()   

根据位置找字符：str.charAt()  str.substring()   str.slice()   str.substr()

根据字符替换字符: str.replace()

根据符号分隔字符：str.split()


9、对象

创建对象：var car = new Object();       var car = {};

eg:
var car = {
	color:'red',
	run:function () {alert('run')}
};

car.color;   //"red"
car["color"] //"red"    这里可以用中括号的形式来访问值。
car.run();   //alert("run")   这里访问的方法需要加括号。
car["run"]() //alert("run")   这里可以通过中括号的形式来访问方法。记得也要加括号

如何给已有对象增加属性和方法：
eg:
car.type="SUV";
car.stop=function () {alert("stop")};

修改属性：
eg:
car.color="white";

删除属性：
eg:
delete car.color;
delete car.stop;   //如果要删除方法的话，是不需要加括号的，加了括号会删除失败。

构建该对象的构造函数：obj.constructor
eg:
car.constructor;   //Object

var num = new Number(123);
num.constructor;   //Number

将对象转换成字符串：obj.toString()

var num = new Number(123);
num.toString();    //"123"

获取对象原始值：obj.valueOf()
eg:
var num = new Number(123);
num.valueOf();      //123

查看自身是否具有某个属性和方法：obj.hasOwnproperty()    (必须是自身的属性，如果继承过来的也会返回false)
eg:
var car = {
	color:"red";
	run:function () {alert("run")}
};
car.hasOwnproperty("color");   //true
car.hasOwnproperty("logo");    //false


10、数组

获取数组中某个元素的位置：arr.indexOf(searchElement[,fromIndex=0])
接受两个参数，第一个参数表示要查找的元素，第二个参数表示查找的起始位置（不常用）。
这个只能查字符串所在位置，如果数组内是对象，是查不到的。

遍历数组并对数组内容执行回调函数：arr.forEach(callback[,thisArg])
接受两个参数，第一个参数是回调函数，第二个参数会替换掉回调函数里的this对象（不常用）。
这个是需要用回调函数的。
回调函数格式：function (item,index,array) {}    //必须写三个参数，可以不全部用到，但是必须要写。
                                                //第一个参数表示传入的元素，第二个是索引，第三个是数组。

将数组倒序排列：arr.reverse()

按照某个条件进行排列：arr.sort([compareFunction])
接受一个参数，参数就是可以形成条件的那个回调函数。
这个函数会改变原来的数组。
可以不传入参数，如果不传参数，会按照unicode的顺序来排序。
这个是需要用回调函数的。
回调函数格式：function(a,b){return a-b;}    //必须写两个参数。
                                            //两个参数表示比较的两个值，相减以后哪个小，将排在前面。
                                            //如果返回的是b-a，那么哪个大，将会排在前面。

向数组内末尾添加元素：arr.push(element1,element2...)

向数组内头部添加元素：arr.unshift(element1,element2...)

获取数组内第一个元素，并将数组内的第一个元素删除：arr.shift()

获取数组内最后一个元素，并将数组内的最后一个元素删除：arr.pop()

向数组任意位置删除并添加元素：arr.splice(index,howMany[,ele1[,ele2[,eleN]]])
接收三个参数，第一个参数表示索引位置，第二个位置表示删除多少个元素，第三个参数表示在当前位置插入的元素。
如果不传第三个参数，就表示只删除。如果第二个参数是0，就表示只插入，但是插入的元素在所在位置的前面。
注：这个方法其实可以做三件事：1、替换 2、删除 3、添加

reverse、sort、push、unshift、shift、pop、splice都会改变原数组。

复制数组内的元素：arr.slice(begin[,end])
开始位置包含，结束位置不包含。
结果进行再次赋值以后会形成新数组。

将数组做连接：arr.concat(value1,..,valueN)
参数不一定非得是数组，其它的元素也是可以连接的。

将数组以特定的字符连接成一个字符串：arr.join([separator])
如果不传参数，默认是以逗号分隔，如果传入空字符串，就直接连接了。

将原有数组数据修改以后形成一个新数组：这里就用一整套方法了。
创建一个新的空数组，然后先将原数组遍历(forEach)，回调函数里将原数组的内容进行修改，修改后添加到新数组内(push)。

将原有数组进行修改并形成新数组：arr.map(callback[,thisArg])
和forEach()相似，不同点在于这里循环以后得到的值会成形成一个新数组。赋值以后就可以使用。
回调函数格式：function(item,index,array) {return}   //记得这里要return

将数组内容累加：arr.reduce(callback,[initialValue])
可以用来处理每次遍历到的元素和上一次元素之间的关系。
接受两个参数，第一个参数是上一次处理以后得到的值。第二个参数是在第一次计算之前的第一个参数的初始值。
回调函数格式：function (previousResult,item,index,array){return previousResult + item.value};

slice、concat、join、map、reduce对原有的数组没有修改。

需要回调函数的几个方法：forEach()  sort()  map()   reduce()


11、函数

如果实参小于形参，那么未定义的形参将会取值undefined。
如果实参大于形参，那么多出来的实参函数将接收不到。但是如果想访问的话，arguments属性将可以访问的到。
arguments是一个实参的集合，通过循环可以访问到具体的实参。

函数的参数如果是原始类型的话，就是值传递。在函数处理完成以后，它并不会影响原来的参数。
函数的参数如果是对象类型的话，就是引用传递，在函数处理完成以后，原本的属性会受到影响。

作用域：

当当前函数内存在该变量时，函数内的操作将会使用函数内的变量，如果函数内没有相关的变量，函数将会向外层查找相关的变量。

this:调用这个函数的对象

构造函数：

构造函数的调用：var point=new Point(1,1);   //注意，加了new的表示调用的是构造函数

原型：prototype


















































































































