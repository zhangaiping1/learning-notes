1、文档树

2、节点操作

根据CSS选择器获取元素（querySelector）
querySelector:只返回第一个查找到的节点。
querySelectorAll:返回所有符合条件的节点。
接收的参数是CSS选择器。
eg:
var list = elm.querySelectorAll('#md .top .act,.foot');

创建节点：
createElement:
innerHTML:如果给添加的节点添加事件，只能通过onclick的方式在HTML里添加。而不能使用addEventLisner来添加。

插入节点：
appendChild:插入到尾部 eg: parent.appendChild(newElm);
insertBefore:插入到某个节点之前  eg: parent.insertBefore(newElm,rElm);   //rElm:插入到这个节点之前
insertAdjacentElement:插入一个元素节点，插入到某个元素的开标签之前、之后，闭标签之前、之后。
格式：elm.insertAdjacentElement(sWhere,oElm);   
sWhere:beforeBegin  afterBegin  beforeEnd   afterEnd   elm:参照节点    oElm:要插入的元素    
insertAdjacentHTML:插入一个带标签的字符串。（因为效率问题（隐式类型转换），不太建议。）
eg:
var str = '<span>abc</span>';
p.insertAdjacentElement('afterBegin',str);

文档上的所有节点类型都是由HTMLElement派生出去的。所以他们的原型都是HTMLElement.prototype

修改节点：
innerHTML:
textContent(innerText，这个需要兼容)(修改文本内容):

在对象定义后通过Object的__defineGetter__、__defineSetter__方法来追加定义
例如我们给Date对象添加一个year属性： 
Date.prototype.__defineGetter__('year', function() {return this.getFullYear();});     
Date.prototype.__defineSetter__('year', function(y) {this.setFullYear(y)});     

var now = new Date;     
alert(now.year);     
now.year = 2006;     
alert(now);    


删除节点：(删除之前记得将节点上的事件移除掉，然后进行删除的操作)
removeChild(删除某个子节点，返回删除的节点): eg: parent.removeChild(child);
另可以只需要传入一个被删除的节点参数，就可以删除该节点：
function remove(elm) {
	elm.parentNode.removeChild(elm);
}
      
replaceChild（替换节点，返回值是被删除的节点）:  eg: parent.replaceChild(newChild,oElm);
newChild:需要插入的节点   oElm:需要删除的节点  

3、属性操作

property accessor
getAttribute/setAttribute
dataset

property accessor(属性访问器):
读：eg: input.value;
写：eg: input.value='wwq@163.com';
好处：获得的都是实用对象，比如class获得的就是字符串，length获得的就是数值型。
坏处：通用性差，因为名字有一些不一样。比如className  htmlFor等。
      扩展性差，HMTL里添加属性，DOM里就需要添加内容。

g/setAttribute:
读：elm.getAttribute(attributeName)
写：elm.setAttribute(name,value);
好处：通用性好，名字不会有异常问题。
坏处：访问到的都是属性的字符串。

以上两种：纯字符串操作，选择setAttribute  ，如果涉及到实用属性操作，则选择属性访问器。

dataset:

HTMLElement.dataset
data-*属性集
eg:<div data-id = '123456' data-account-name = 'wwq'>wwq</div>
   div.dataset.id  //123456
   div.dataset.accountName   //wwq
data-*的用处：元素上保存数据
用处：用户的卡片信息
比如放到一个用户的名称上，然后显示一个像名片一样的信息表。这些信息就可以以自定义的方式来写入HTML，然后用dataset来获取。

4、样式操作

对于外链样式和内联样式的访问：
element.sheet.cssRules[0].style.lineHeight

对于行内样式的访问：
element.style.color

对于一次性设置CSS多个属性：
element.style.cssText = 'border-color:red;color:red;';

如何更好的将样式分离出去(更新CSS最好的方法)：
更新class:
eg:
element.className += 'invalid';

怎么样更换更多的样式：更换样式表
给链接上加个ID,然后获取到以后通过ele.href = 'xx.css';就可以达到更换样式表。

获取样式：
element.style:只能获取到行内样式。

如何获取到所有的实际的样式值：
var style=window.getComputedStyle(element[,pseudoElt])  //这个方法IE8及以下不支持
接受两个参数，第一个参数是要获取样式的元素，第二个参数是伪类。
eg:
window.getComputedStyle(element).color;    //'rgb(255.0.0)'

IE9以下解决办法：
element.currentStyle:

5、事件

事件流：
capture phase(捕获)
target phase(目标)
bubble phase(冒泡)
从window开始： window-document-html-body-... -目标元素的父节点 (捕获)
从目标元素的父节点开始： 父节点-目标-父节点（目标）
从目标元素的节节点开始： 父节点-...-body-html-document-window  (冒泡)

并不是所有的浏览器都有这三个过程，比如IE的低版本浏览器没有捕获过程
并不是所有的事件都有这三个过程，比如有一些事件没有冒泡过程。比如页面的load事件就没有冒泡过程。

事件注册与触发：

事件注册：
eventTarget.addEventListener(type,listener[,useCapture])
eventTarget:DOM元素  type:事件类型  listener:事件处理函数  useCapture:是否为冒泡时处理
默认是冒泡时处理(false)，如果是ture，会是捕获时处理）

另外还有一种方法：eventTarget.onclick=function () {}  //缺点：这种方法只能注册一个事件。

取消事件注册：
eventTarget.removeEventListener(type,listener[,useCapture])


事件触发(确定触发方式)：
eventTarget.dispatchEvent(type)
eg:
elem.dispatchEvent('click');

关于IE6\7\8的浏览器兼容性：
首先：IE的浏览器注册事件需要带on ,例：elem.attachEvent('on'+click,listener);
事件注册与取消：
attchEvent/detachEvent:
事件触发：
fireEvent(e)

IE6\7\8没有捕获阶段，因此就没有第三个参数。

事件对象(event)：
function clickHandler(event) {};

关于IE兼容性：
IE低版本浏览器不是简单的event对象，他会将event放到window中。因此需要兼容一下。
function(event) {
	event = event || window.event;
}
当浏览器查不到event时，则查找window.event

事件对象的属性和方法：
属性：
type:事件类型
target(srcElement):事件触发节点
currentTarget:当前处理的事件节点。

方法：
阻止事件传播：
event.stopPropagation(); (W3C)（阻止冒泡）
event.cancelBubble = true (IE) (IE下的阻止冒泡)
event.stopImmediatePropagation() (阻止冒泡并阻止该节点的后续事件)

默认行为：
event.preventDefault() (W3C)
event.returnValue = false (IE)

事件分类：



























